'use strict'

// let promise = new Promise(function(resolve, reject) {
//     // ф-я-исполнитель (executor)
//     // "певец"
// });

// // Ф-я, переданная в конструкцию new Promise наз-ся исполнитель (executor).
// // Когда объект Promise создаётся, она запускается автоматически. Она 
// // должна содержать код, к-й к.-нибудь создаст результат (в асинхронном режиме, ведь?).
// // resolve и reject - это колбэки, к-е предоставляет САМ JS, наш код только
// // внутри исполнителя. Итак, исполнитель запускается автоматически, он должен
// // выполнить работу (сейчас или позже - не важно), а затем вызвать:
// // - resolve(value) - если работа завершилась успешно, с рез-ом value;
// // - reject(error) - если произошла ошибка, error - объект ошибки

// // У объекта promise есть ВНУТРЕННИЕ св-ва:
// // - state - вначала "pending", потом меняется на "fulfilled" при вызове
// // resolve или на "rejected" при вызове reject.
// // - result - вначале undefined, потом меняется на value при вызове 
// // resolve(value) или на error при  вызове rejected(error)

// // Пример конструктора Promise и простого исполнителя с кодом, дающим результат
// // с задержкой (через setTimeout):
// let promise = new Promise(function(resolve, reject){
//     console.log('Ф-я внутри executor выполнилась автоматически, при вызове new Promise');
//     // через 1 сек. сигнализировать, что задача выполнена с результатом "done"
//     setTimeout(() => {
//         resolve("done");
//         console.log("done через секунду");
//     }, 1000);
// });

// // Пример, в котором исполнитель сообщит, что задача выполнена с ошибкой:
// let promise = new Promise(function(res, rej) {
//     // через 1 сек., б. сообщено, что задача выполнена с ошибкой
//     setTimeout(() => {
//         let error = new Error("Whoops!"); // в консоле отображается ошибка
//         rej(error);
//         console.log(error, 'ошибка через секунду');
//     });
// });



// МОЖЕТ БЫТЬ ЧТО-ТО ОДНО: ЛИБО РЕЗУЛЬТАТ, ЛИБО ОШИБКА
// Состояние промиса может быть изменено только один раз.
// Идея в том, что задача, выполняемая исполнителем, может иметь только 
// один итог: результат или ошибку.
// Все последующие вызовы resolve и reject будут проигнорированы:

let promise = new Promise(function(resolve, reject) {
  resolve("done");

  reject(new Error("…")); // игнорируется, и ошибка в консоли не повляется
  setTimeout(() => resolve("…")); // игнорируется
});

// Вызывайте reject с объектом Error.