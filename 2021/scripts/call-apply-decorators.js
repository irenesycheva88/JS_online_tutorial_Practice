'use strict'


// // ПРОЗРАЧНОЕ КЕШИРОВАНИЕ

// // Создание кэширующей обёртки (wrapper) для ф-и, выполняющей ресурсоёмкие 
// // вычисления, но возвращающей стабильные результаты
// function slow(x) {
//     // здесь могут быть ресурсоёмкие вычисления
//     console.log(`Called with ${x}`);
//     return x;
// }

// function cachingDecorator(func) {
//     let cache = new Map;

//     return function(x) {         // эта ф-я и есть обёртка
//         if (cache.has(x)) {      // если кеш содержит такой x,
//             return cache.get(x); // читаем из кеша результат
//         }

//         let result = func(x);  // иначе, вызываем функцию

//         cache.set(x, result);  // и кешируем (запоминаем) результат
//         return result;
//     }
// }

// slow = cachingDecorator(slow);

// console.log(slow(1));
// console.log('Again: ', slow(1));

// console.log(slow(2));
// console.log('Again: ', slow(2));

// cachingDecorator – это декоратор
// ДЕКОРАТОР - спец. ф-я, к-я принимает другую ф-ю и изменяет её поведение.

// Идея состоит в том, что мы можем вызвать декоратор (в примере cachingDecorator) с любой
// функцией, в результате чего мы получим обёртку - ту самую ф-я, которую возвращает
// декоратор (в нашем случае мы получаем кеширующую обёртку - т.е. ф-ю занимающуюся
// кешированием результатов для нашей основной ф-и).

// Это здорово, т.к. у нас может быть множество ф-й, использующих такую функциональность,
// и всё, что нам нужно сделать – это применить к ним декоратор (в примере cachingDecorator).

// Отделяя добавленный код от основного кода, мы также сохраняем чистоту и простоту последнего.

// Результат вызова cachingDecorator(func) является «обёрткой», 
//т.е. function(x) «оборачивает» вызов func(x) в кеширующую логику.

// Подводя итог, м. выделить несколько преимуществ использования отдельной cachingDecorator 
// вместо изменения кода самой slow:
// 1) Функцию cachingDecorator можно использовать повторно. Мы можем применить её 
// к другой функции.
// 2) Логика кеширования является отдельной, она не увеличивает сложность 
// самой slow (если таковая была).
// 3) При необходимости мы можем объединить несколько декораторов.



// // ПРИМЕНЕНИЕ «FUNC.CALL» ДЛЯ ПЕРЕДАЧИ КОНТЕКСТА.

// let user = new function() {
//     this.name = 'Вася';
//     this.isAdmin = false;
  
//     // ...другой код для создания пользователя
//     // возможна любая сложная логика и выражения
//     // локальные переменные и т. д.
//   };

//   console.log(user);


// // Тут отвлеклась, чтобы поизучать arguments - аргументы ф-и
//   function f(a, b, c) {
//       console.log(arguments, typeof(arguments)); // итерируемый объект и псевдомассив
//       let args = Array.from(arguments);
//       console.log(args, typeof(args));
//   }

//   f(1, 2, 3);
//   f(1, 2, 3, 4, 5, 6, 7);

